#!/usr/bin/python3
from jinja2 import Environment, FileSystemLoader, StrictUndefined
import socket
import os
from pprint import pp
from enum import Enum
import shutil
import sys
import subprocess
import inspect
import re
import hashlib
import datetime

# Empty    : (Nothing-ToDo)   Template is empty (after processing), and managed file does not exist
# Same     : (Nothing-ToDo)   Template is not empty (either templated or not), managed file exists, and content is the same
# Extra    : (Something-ToDo) Template is empty (after processing), but managed file does exist
# Missing  : (Something-ToDo) Template is not empty (either templated or not), but managed file does not exist
# Different: (Something-ToDo) Template is not empty (either templated or not), managed file exists, but content is different

class TemplateMode(Enum):
	ExtensionOnly = 2
	AllExceptExtension = 3

class TemplateHandleMode(Enum):
	Copy = 1
	ApplyTemplate = 2
	SkipEmpty = 3
	SkipUnmodified = 4

class TemplateFile:
	__slots__ = (\
		'RelativePath', 'NoTemplateExtension', 'IsTemplate', 'IsEmpty', 'Status', \
		'Template_mtime', \
		'Managed_mtime', 'Last_Managed_mtime', 'Last_Status', \
		'TemplateContent', 'Rendered')
	
	def __init__(self, RelativePath, Template_mtime=None):
		self.RelativePath = RelativePath
		self.NoTemplateExtension = ''
		self.IsTemplate = True
		self.IsEmpty = False
		self.Status = None
		self.Managed_mtime = None
		self.Template_mtime = Template_mtime
		self.Last_Managed_mtime = None
		self.Last_Status = None
		self.TemplateContent = None
		self.Rendered = None
		
		# Check if file is explicitly non-template due to extension
		BasePath,Extension = os.path.splitext(RelativePath)
		if Extension in ['.notmpl', '.notemplate']:
			self.RelativePath = BasePath
			self.NoTemplateExtension = Extension
			self.IsTemplate = False
		
		if Template_mtime is None: self.Template_mtime = os.path.getmtime(self.getTemplatePath())
		
	def LOG(self, level=4, prefix=''):
		LOG(level, f"{prefix}" \
			f"NoTemplateExtension={self.NoTemplateExtension}, " \
			f"IsTemplate={self.IsTemplate}, " \
			f"IsEmpty={self.IsEmpty}, " \
			f"Status={self.Status}, " \
			f"RelativePath={self.RelativePath}: " \
			f"TemplateContent={type(self.TemplateContent)}..., " \
			f"Rendered={type(self.Rendered)}..., " \
			f"Template_mtime={self.Template_mtime}, " \
			f"Managed_mtime={self.Managed_mtime}, " \
			f"Last_Managed_mtime={self.Last_Managed_mtime}, " \
			f"Last_Status={self.Last_Status}, " \
			)
			#f"getTemplatePath={self.getTemplatePath()}, " \
			#f"getManagedPath={self.getManagedPath()}, "\
	
	def getTemplatePath(self):
		return(os.path.join(TemplateDirectory, self.RelativePath + self.NoTemplateExtension))
	
	def getManagedPath(self):
		return(os.path.join(ManagedDirectory, self.RelativePath))
	
	def getCachePath(self):
		return(os.path.join(CacheDirectory, self.RelativePath))
	
	def generateRunLog(self):
		return( \
			f"{self.RelativePath}," \
			f"{self.IsTemplate}," \
			f"{self.IsEmpty}," \
			f"{self.Status}," \
			f"{self.Template_mtime}," \
			f"{self.Managed_mtime}," \
			"EOL"
			)
	
	def loadRunLog(self, Line):
		# Split log line into fields
		RelativePath, IsTemplate, IsEmpty, Status, Template_mtime, Managed_mtime, EOL = Line.strip().split(',')
		LOG(4, "RunLog-1: " \
		       f"RelativePath={type(RelativePath)}{RelativePath}, " \
		       f"IsTemplate={type(IsTemplate)}{IsTemplate}, " \
		       f"IsEmpty={type(IsEmpty)}{IsEmpty}, " \
		       f"Status={type(Status)}{Status}, " \
		       f"Template_mtime={type(Template_mtime)}{Template_mtime}, " \
		       f"Managed_mtime={type(Managed_mtime)}{Managed_mtime}, " \
		       )
		if RelativePath != self.RelativePath:
			raise RuntimeError(f"ERROR: Loading runlog: self.RelativePath={self.RelativePath}; runlog.RelativePath={RelativePath}")
		
		# Data type conversion
		IsTemplate = IsTemplate in ['True', '1']
		IsEmpty = IsEmpty in ['True', '1']
		Template_mtime = float(Template_mtime)
		if Managed_mtime == "None":
			Managed_mtime = None
		else:
			Managed_mtime = float(Managed_mtime)
		
		LOG(4, "RunLog-2: " \
		       f"RelativePath={type(RelativePath)}{RelativePath}, " \
		       f"IsTemplate={type(IsTemplate)}{IsTemplate}, " \
		       f"IsEmpty={type(IsEmpty)}{IsEmpty}, " \
		       f"Status={type(Status)}{Status}, " \
		       f"Template_mtime={type(Template_mtime)}{Template_mtime}, " \
		       f"Managed_mtime={type(Managed_mtime)}{Managed_mtime}, " \
		       )
		
		# If template mtime is different, can't rely on any run log cache
		if Template_mtime != self.Template_mtime:
			LOG(4, f"Cannot use RunLog: {RelativePath}: RunLog mtime={type(Template_mtime)}{Template_mtime}; filesystem={type(self.Template_mtime)}{self.Template_mtime}")
			return
		else:
			LOG(4, f"Using RunLog!")
		
		# Update whether file is a template for:
		#  * faster cache processing (if cache is missing; although not sure cache could be missing while still getting runlog)
		#  * Ability to add file directly from managed directory to template directory
		self.IsTemplate = IsTemplate
		
		# IsEmpty indicates file should not be in managed directory
		self.IsEmpty = IsEmpty
		
		self.Last_Managed_mtime = Managed_mtime
		self.Last_Status = Status
		self.LOG(4, "After RunLog: ")
		
	def UpdateCache(self):
		with open(self.getTemplatePath(), 'r') as file:
			self.TemplateContent = file.read()
			
		## Load and apply template
		try:
			template = TemplateTool.get_template(self.RelativePath)
		except Exception as e:
			print(f"ERROR: {RelPath}: Template processing error: {e}.  Cache *NOT* updated.")
			return
		
		self.Rendered = template.render(TemplateData)
		
		# Check if empty
		if not self.Rendered.strip():
			self.IsEmpty = True
			return
		self.IsEmpty = False  #should already be set
		
		# Check if not actually templated
		if (self.Rendered == self.TemplateContent) or (self.Rendered == self.TemplateContent[:-1]):
			self.IsTemplate = False
			return
		self.IsTemplate = True  #Should already be set
		
		# If here: there is content, and it does use templating.  Save content.
		#RenderedContent = self.Rendered.encode('utf-8')
		#print(f"Rendered={type(Rendered)}")
		#print(f"RenderedContent={type(RenderedContent)}")
		CachePath = self.getCachePath()
		CacheDir = os.path.dirname(CachePath)
		os.makedirs(CacheDir, exist_ok=True)
		with open(CachePath, 'w') as file:
			file.write(self.Rendered)
	
	def CalculateStatus(self):
		try:
			Managed_stat = os.stat(self.getManagedPath())
			self.Managed_mtime = Managed_stat.st_mtime
			#os.path.getmtime(self.getManagedPath())
		except FileNotFoundError:
			self.Managed_mtime = None
		
		#TO DO: handle executable mode
		
		LOG(4, f"CalculateStatus():")
		self.LOG(4, f"CalculateStatus: 1: ")
		
		#Implied (through loadRunLog): self.Template_mtime == self.Last_Template_mtime \
		if    (self.Managed_mtime == None and self.IsEmpty) \
		   or (self.Managed_mtime is not None and self.Managed_mtime == self.Last_Managed_mtime):
			self.Status = self.Last_Status
			LOG(4, f"    Was able to use cache")
			self.LOG(4, 'CalculateStatus: final after cache: ')
			return False
		LOG(4, f"    Did NOT use cache")
		
		if self.IsTemplate:
			self.UpdateCache()
			self.LOG(4, f"CalculateStatus: After-UpdateCache: ")
		else:
			with open(self.getTemplatePath(), 'r') as file:
				self.TemplateContent = file.read()
			self.Rendered = self.TemplateContent
			self.LOG(4, f"CalculateStatus: Not-a-template_Skipping-UpdateCache: ")
		
		if self.Managed_mtime is     None and     self.IsEmpty:
			self.Status = 'Empty'
			return True
		
		if self.Managed_mtime is not None and     self.IsEmpty:
			self.Status = 'Extra'
			return True
		
		if self.Managed_mtime is     None and not self.IsEmpty:
			self.Status = 'Missing'
			return True
		
		if self.Managed_mtime is not None and not self.IsEmpty:
			# File exists and should exist, is not a template: need to compare content Template to Managed content
			with open(self.getManagedPath(), 'r') as file:
				ManagedContent = file.read()
			
			if ManagedContent == self.Rendered:
				self.Status = 'Same'
			else:
				self.Status = 'Different'
				#with open('/home/abanker/tmp/ManagedContent.txt', 'w') as FH:
				#	FH.write(ManagedContent)
				#with open('/home/abanker/tmp/Rendered.txt', 'w') as FH:
				#	FH.write(self.Rendered)
				#if self.RelativePath == 'bin/state-logger': raise RuntimeError('DEBUG')
			return True
		
		raise RuntimeError(f"Do not know how to calculate status\n")

## Define global variables
current_verbosity = 2
TemplateMode = TemplateMode.AllExceptExtension
CacheDirectory = ''  #Actual value set in main
TemplateDirectory = ''  #Actual value set in main
ManagedDirectory = ''  #Actual value set in main
#https://jinja.palletsprojects.com/en/stable/templates/#whitespace-control
TemplateTool = None
RunLog = ''
Files = {}
TemplateData = {}
ConfigData = {}





def LOG(verbosity_level, message):
	if current_verbosity >= verbosity_level:
		print(message)

#ManagedDirectory = "/home/abanker"
#TemplateDirectory = "/home/abanker/vc/anbanker/config-home"
#f1=TemplateFile('bin/backup-snapshot')
#f1.LOG(1, 'f1: ')
#print(f"RunLog={f1.generateRunLog()}")
#f2=TemplateFile('some/other/raw.txt.notmpl')
#f2.LOG(1, 'f2: ')
#print(f"Join result={'/'.join(['', ''])}")
#exit(0)


def LoadTemplateFiles_OneDir(RootDir, RelativeDir):
	#print(f"LoadTemplateFiles_OneDir('{RootDir}', '{RelativeDir}')")
	ScanDir = '/'.join([RootDir, RelativeDir])
	#print(f"  ScanDir={ScanDir}")
	with os.scandir(ScanDir) as it:
		if RelativeDir != '': RelativeDir = RelativeDir + '/'
		#print(f"  RelativeDir='{RelativeDir}'")
		for entry in it:
			RelativePath = RelativeDir + entry.name
			if entry.is_file():
				# Skip special files
				if entry.name[-7:] == '.cfgmgr': continue
				if entry.name == '.gitignore': continue
				if RelativePath == 'README.md': continue
				
				# Add to Files
				f = TemplateFile(RelativePath, Template_mtime=entry.stat().st_mtime)
				Files[f.RelativePath] = f #Must do this with f.RelativePath, not RelativePath, in case extension removed
			elif entry.is_dir():
				if entry.name in ['.git']: continue
				LoadTemplateFiles_OneDir(RootDir, RelativePath)

def LoadTemplateFiles():
	Dir = TemplateDirectory.rstrip('/')
	LoadTemplateFiles_OneDir(Dir, '')
	
	for RelPath,attr in Files.items():
		attr.LOG(4, "cfgmgr: LoadTemplateFiles: FileSummary: ")

def LoadRunLog():
	if not os.path.exists(RunLog): return
	
	LOG(3, 'cfgmgr: LoadTemplateFiles: Loading run log...')
	with open(RunLog, 'r') as file:
		for line in file:
			# Skip comments
			if line.startswith('#'): continue
			if not line: continue
			
			# Process line - get RelativePath, then pass string to object to process
			comma_index = line.find(',')
			if comma_index == -1: raise RuntimeError("Improper RunLog line")
			RelativePath = line[:comma_index]
			LOG(4, f"Found RunLog line for RelativePath={RelativePath}")
			if RelativePath not in Files:
				LOG(4, f"Skipping due to RelativePath not in Files")
				continue
			Files[RelativePath].loadRunLog(line)
			Files[RelativePath].LOG(4, f"cfgmgr: LoadRunLog: FileSummary: ")

def LoadTemplateData():
	# Automatic template data
	TemplateData['hostname'] = socket.gethostname()
	TemplateData['IsWSL'] = os.path.exists('/proc/sys/fs/binfmt_misc/WSLInterop')
	
	# User provided template data
	TemplateDataFile = os.path.join(TemplateDirectory, 'private-data.cfgmgr')
	if os.path.exists(TemplateDataFile):
		# Read file
		with open(TemplateDataFile, 'r') as file:
			# Process each line
			for line in file:
				# Skip comments
				if line.startswith('#'): continue
				
				# Split line into key and value
				key, value = re.split(r'\s*=\s*', line.strip(), 1)
				
				# Add to TemplateData
				TemplateData[key] = value

def LoadConfigData():
	# Defaults
	ConfigData['difftool'] = '/usr/bin/meld'
	
	# User provided template data
	ConfigDataFile = os.path.join(TemplateDirectory, 'config-data.cfgmgr')
	if os.path.exists(ConfigDataFile):
		# Read file
		with open(ConfigDataFile, 'r') as file:
			# Process each line
			for line in file:
				line = line.rstrip('\n')
				# Skip comments and empty lines
				if line.startswith('#'): continue
				if not line: continue
				
				# Split line into key and value
				print(f"DEBUG: line={line};")
				key, value = re.split(r'\s*=\s*', line.strip(), 1)
				
				# Add to TemplateData
				ConfigData[key] = value

def CleanCacheFiles():
	LOG(3, f'cfgmgr: CleanCacheFiles: Beginning cache clean ({CacheDirectory})...')
	os.remove(CacheDirectory)
	os.remove(RunLog)

def UpdateRunlog():
	RunLogDir = os.path.dirname(RunLog)
	os.makedirs(RunLogDir, exist_ok=True)
	with open(RunLog, 'w') as FH:
		FH.write(f"## {datetime.datetime.now()}\n")
		for RelPath, attr in Files.items():
			FH.write(attr.generateRunLog() + "\n")

def CalculateStatus():
	LOG(3, f'cfgmgr: CalculateStatus: Start')
	
	Updated = False
	for RelPath, attr in Files.items():
		LOG(4, f'cfgmgr: CalculateStatus: Processing {RelPath}')
		Updated1 = attr.CalculateStatus()
		Updated = Updated or Updated1 
		attr.LOG(4, f"cfgmgr: After CalculateStatus: Updated={Updated1},{Updated}: ")
	
	# TO DO: Do not update run log if calculating status for Apply, since it'll be updated again with Apply
	if Updated:
		UpdateRunlog()

def DisplayStatus():
	print('## git status')
	
	# Run git status, capture output
	GitLines = subprocess.run(['git', '-C', TemplateDirectory, 'status'], capture_output=True)
	for Line in GitLines.stdout.decode().split('\n'):
		print(f"    {Line}")
	
	#subprocess.run(['git', '-C', TemplateDirectory, 'status'], text=True)
	NeedTitle=1
	for RelPath, attr in Files.items():
		## Skip statuses that aren't needed to be displayed
		if attr.Status == 'Same': continue
		if attr.Status == 'Empty': continue
		
		if NeedTitle:
			print("## Differences between template repo and working directory:")
			print("   Run 'cfgmgr apply' to apply template to working directory")
			NeedTitle=0
		
		print(f"    {attr.Status.ljust(13)}: {RelPath}")
	
	# If there were no differences (still need title), display title indicating this
	if NeedTitle:
		print(f"## No differences between template working directory and managed directory!")

def GetGitStatusOneline():
	output = subprocess.run(['git', '-C', TemplateDirectory, 'status', '--porcelain=v2', '--branch'], capture_output=True)
	if output.returncode != 0:
		return 'git-error'
	
	OutputLines = output.stdout.decode().split('\n')
	
	# Process git OutputLines to get summary
	Ahead = 0
	Behind = 0
	StatusCount = {}
	for line in OutputLines:
		if not line: continue
		match = re.match(r'^# branch.ab \+(?P<Ahead>\d+) \-(?P<Behind>\d+)', line)
		if match:
			Ahead = int(match.group('Ahead'))
			Behind = int(match.group('Behind'))
			continue
		if re.match(r'^#', line):
			continue
			# Do nothing
		
		match = re.match(r'^1 (?P<XY>..) (?P<SubmoduleState>....) (?P<modeHead>[0-7]{6}) (?P<modeIndex>[0-7]{6}) (?P<modeWorktree>[0-7]{6}) (?P<hashHead>[0-9a-f]{40}) (?P<hashIndex>[0-9a-f]{40}) (?P<path>.+)$', line)
		if match:
			# X is index; Y is working-tree
			if   match.group('XY') == 'A.': StatusCount['A'] = StatusCount.get('A', 0) + 1
			elif match.group('XY') == '.M': StatusCount['m'] = StatusCount.get('m', 0) + 1
			elif match.group('XY') == '.D': StatusCount['d'] = StatusCount.get('d', 0) + 1
			elif match.group('XY') == 'M.': StatusCount['M'] = StatusCount.get('M', 0) + 1
			else:                           StatusCount['?'] = StatusCount.get('?', 0) + 1
			continue
			
		if   re.match(r'^\? (?P<path>.*)$', line): StatusCount['u'] = StatusCount.get('u', 0) + 1
		elif re.match(r'^! (?P<path>.*)$', line) : StatusCount['i'] = StatusCount.get('i', 0) + 1
		else                                     : 
			StatusCount['?'] = StatusCount.get('?', 0) + 1
			print(f"DEBUG: Unmatched line: {line}")
	
	OutputString = ''
	for key, value in StatusCount.items():
		OutputString += f"{key}{value}"
	
	#This looked correct on WSL, but not native
	#if($Ahead       ) { $str .= "⭡$Ahead"; }
	#if($Behind      ) { $str .= "⭣$Behind"; }
	#This looks correct on native
	if Ahead : OutputString += f"⇡{Ahead}"
	if Behind: OutputString += f"⇣{Behind}"
	
	return OutputString

def PrintStatusOneline():
	## Get git status
	GitString = GetGitStatusOneline()
	
	## Get working status
	Extra=0
	Missing=0
	Diff=0
	for RelPath, attr in Files.items():
		# Skip files with "same" status
		if attr.Status == 'Empty':
			pass
		elif attr.Status == 'Same':
			pass
		elif attr.Status == 'Extra':
			Extra=Extra+1
		elif attr.Status == 'Missing':
			Missing=Missing+1
		elif attr.Status == 'Different':
			Diff=Diff+1
		else:
			raise RuntimeError('Unhandled status')
		
	WorkingString = ''
	if Extra: WorkingString += f"E{Extra}"
	if Missing: WorkingString += f"M{Missing}"
	if Diff: WorkingString += f"D{Diff}"
	
	Separator = ''
	if WorkingString and GitString:
		WorkingString = f"W:{WorkingString}"
		GitString = f"G:{GitString}"
		Separator = ' '
	print(f"{WorkingString}{Separator}{GitString}")

def Apply(FilesToApply):
	LOG(3, f'cfgmgr: Apply: Applying...')
	
	Force = False
	while (len(FilesToApply) > 0) and (FilesToApply[0][0] == '-'):
		arg = FilesToApply.pop(0)
		if arg == '--force':
			Force = True
		elif arg == '--':
			break
		else:
			raise RuntimeError(f"Unknown option: {arg}")
	
	# If no files specified, apply all
	if not FilesToApply:
		FilesToApply = list(Files.keys())
	
	for RelPath in FilesToApply:
		LOG(4, f'cfgmgr: Apply:   File={RelPath}')
		if RelPath not in Files:
			raise RuntimeError(f"ERROR: {RelPath} is not managed")
		
		attr = Files[RelPath]
		
		LOG(4, f"cfgmgr: Apply:     Status={attr.Status}")
		WriteLog = False
		if attr.Status == 'Same':
			# Nothing to do
			LOG(3, f"{RelPath}: Skipping update (template and managed file are identical)")
		elif attr.Status == 'Empty':
			# Nothing to do
			LOG(3, f"{RelPath}: Skipping update (file is empty after processing template, and managed file does not exist)")
		elif attr.Status == "Extra":
			LOG(3, f"{RelPath}: Removing file")
			os.remove(attr.getManagedPath())
			attr.Status = 'Same'
		elif attr.Status == "Missing":
			LOG(3, f"{RelPath}: Creating file")
			ThisFileDir = os.path.dirname(attr.getManagedPath())
			os.makedirs(ThisFileDir, exist_ok=True)
			
			if attr.IsTemplate:
				shutil.copy(attr.getCachePath(), attr.getManagedPath())
			else:
				shutil.copy(attr.getTemplatePath(), attr.getManagedPath())
			attr.Managed_mtime = os.path.getmtime(attr.getManagedPath())
			attr.Status = 'Same'
		elif attr.Status == 'Different':
			# TO DO: Check time of last apply, to not overwrite changes made to managed directory
			if attr.IsTemplate:
				shutil.copy(attr.getCachePath(), attr.getManagedPath())
			else:
				shutil.copy(attr.getTemplatePath(), attr.getManagedPath())
			attr.Managed_mtime = os.path.getmtime(attr.getManagedPath())
			attr.Status = 'Same'
			#print(f"    Managed Directory mod time: {datetime.datetime.fromtimestamp(attr['WorkingLastModTime'])}")
			#print(f"    Last apply mod time       : {datetime.datetime.fromtimestamp(attr['Last_ApplyModTime'])}")
		else:
			raise RuntimeError('Unhandled status')
		
	UpdateRunlog()

def Add(FilesToAdd):
	for RelPath in FilesToAdd:
		ManagedPath = ''
		TemplatePath = ''
		CachePath = ''
		WorkingLastModTime = 0
		if RelPath in Files:
			print("DEBUG: RelPath IS in Files")
			pp(Files[RelPath])
			## Error if file is a template
			if Files[RelPath]['IsTemplate']:
				raise RuntimeError(f"{RelPath}: Cannot add template file from working directory; update template in repo instead.")
			ManagedPath = Files[RelPath]['ManagedPath']
			TemplatePath = Files[RelPath]['TemplatePath']
			CachePath = Files[RelPath]['CachePath']
			WorkingLastModTime = Files[RelPath]['WorkingLastModTime']
		
		## Copy file from working directory to template directory, and set template time to working time
		if not ManagedPath: ManagedPath = os.path.join(ManagedDirectory, RelPath)
		if not TemplatePath: TemplatePath = os.path.join(TemplateDirectory, RelPath)
		if not CachePath: CachePath = os.path.join(CacheDirectory, RelPath)
		if not WorkingLastModTime: WorkingLastModTime = os.path.getmtime(ManagedPath)
		
		TemplateDir = os.path.dirname(TemplatePath)
		os.makedirs(TemplateDir, exist_ok=True)
		shutil.copy(ManagedPath, TemplatePath)
		subprocess.run(['git', '-C', TemplateDirectory, 'add', RelPath], text=True)
		
		#TO DO: Update cache file, verify it matches (no "template" processing errrors)

def Diff(FilesToDiff):
	FileType1 = 'Template'
	FileType2 = 'Managed'
	if FilesToDiff[0] == '--cvw' or FilesToDiff[0] == '--c2w':
		FileType1 = 'Cache'
		FilesToDiff.pop(0)
	elif FilesToDiff[0] == '--tvc' or FilesToDiff[0] == '--t2c':
		FileType2 = 'Cache'
		FilesToDiff.pop(0)
	
	if len(FilesToDiff) == 0:
		raise UserWarning("diff requires arguments")
	
	for RelPath in FilesToDiff:
		if RelPath not in Files:
			raise RuntimeError(f"ERROR: {RelPath} is not managed")
		
		attr = Files[RelPath]
		#subprocess.run(['/usr/bin/bcompare', attr[f'{FileType1}Path'], attr[f'{FileType2}Path']], text=True)
		subprocess.run([ConfigData['difftool'], attr.getTemplatePath(), attr.getManagedPath()], text=True)


if __name__ == "__main__":
	## Remove program name
	ProgramName = sys.argv.pop(0)
	
	# Process options
	ApplyAsRoot = False
	while (len(sys.argv) > 0) and (sys.argv[0][0] == '-'):
		arg = sys.argv.pop(0)
		if arg == '--verbose':
			old = current_verbosity
			current_verbosity = current_verbosity + 1
			print(f"Increasing verbosity {old} -> {current_verbosity}")
		elif arg == '--CacheDir':
			CacheDirectory = sys.argv.pop(0)
		elif arg == '--TemplateDir':
			TemplateDirectory = sys.argv.pop(0)
		elif arg == '--ManagedDirectory':
			ManagedDirectory = sys.argv.pop(0)
		elif arg == '--root':
			ApplyAsRoot = True
		else:
			raise RuntimeWarning(f"Unknown option: {arg}")
	
	## Verify usage
	if not TemplateDirectory:
		raise UserWarning("ERROR: Template directory not specified. Use --TemplateDir")
		#TemplateDirectory = f"{os.environ['HOME']}/vc/anbanker/config-home"
	
	# Set defaults if they aren't set
	if len(sys.argv) < 1:
		print(f"[NOTE]Assuming default sub-command: status")
		SubCommand = 'status'
	else:
		SubCommand = sys.argv.pop(0)
	
	if not CacheDirectory:
		CacheRoot = f"{os.environ['HOME']}/.cache/cfgmgr"
		CacheSubdir = TemplateDirectory.lstrip('/').replace('/','--')
		if not CacheSubdir: CacheSubdir = 'ROOT_DIR'
		CacheDirectory = os.path.join(CacheRoot, CacheSubdir)
	
	if not ManagedDirectory:
		ManagedDirectory = os.environ['HOME']
	
	## Create Template Tool object
	TemplateTool = Environment(
		loader=FileSystemLoader(TemplateDirectory),
		undefined=StrictUndefined,
		trim_blocks=True)
	
	RunLog = os.path.join(CacheDirectory, 'run-log.cfgmgr')
	LoadTemplateFiles()
	LoadRunLog()
	
	# Remove leading "/" on RelPath
	#print(f"part a; value={sys.argv};type={type(sys.argv)};len={len(sys.argv)}")
	#for index in range(0, len(sys.argv)):
	#	sys.argv[index] = sys.argv[index].strip('/')
	
	#exit(1)
	
	
	#if SubCommand == 'UpdateCache':
	#	UpdateCacheFiles()
	if SubCommand == 'CleanCache':
		CleanCacheFiles()
	
	elif SubCommand == 'status':
		LoadTemplateData()
		CalculateStatus()
		DisplayStatus()
	
	elif SubCommand == 'statusOneline':
		LoadTemplateData()
		CalculateStatus()
		PrintStatusOneline()
	
	elif SubCommand == 'git':
		subprocess.run(['git', '-C', TemplateDirectory, '--no-pager', *sys.argv], text=True)
	
	elif SubCommand == 'diff':
		LoadConfigData()
		LoadTemplateData()
		CalculateStatus()
		Diff(sys.argv)
	
	elif SubCommand == 'add':
		UpdateCacheFiles()
		CalculateStatus()
		Add(sys.argv)
	
	elif SubCommand == 'apply':
		CalculateStatus()
		
		## If not root, call again with sudo
		if ApplyAsRoot and (os.geteuid() != 0):
			print("Re-executing as root")
			os.execvp('sudo', ['sudo', sys.executable, ProgramName, '--root', '--TemplateDir', TemplateDirectory, '--CacheDir', CacheDirectory, '--ManagedDirectory', ManagedDirectory, 'apply', *sys.argv])
		#print(f'RUNNING APPLY (as uid={os.geteuid()})!!!');
		Apply(sys.argv)
	else:
		#raise Exception('Usage Error', f"ERROR: Unknown sub-command: {SubCommand}")
		print(f"ERROR: Unknown sub-command: {SubCommand}")
		exit(1)
