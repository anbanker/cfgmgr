#!python3
from jinja2 import Environment, FileSystemLoader
import socket
import os
from pprint import pp
from enum import Enum
import shutil
import sys
import subprocess
import inspect
import re
import hashlib
import datetime

def LOG(verbosity_level, message):
	if current_verbosity >= verbosity_level:
		print(message)

class TemplateMode(Enum):
	ExtensionOnly = 2
	AllExceptExtension = 3

class TemplateHandleMode(Enum):
	Copy = 1
	ApplyTemplate = 2
	SkipEmpty = 3
	SkipUnmodified = 4

class OverallStatus(Enum):
	ExtensionOnly = 2
	AllExceptExtension = 3

def LoadCacheData():
	for root, dirs, files in os.walk(CacheDirectory):
		for file in files:
			FilePath = os.path.join(root, file)
			LastModTime = os.path.getmtime(FilePath)
			FileRelPath = os.path.relpath(FilePath, CacheDirectory)
			if not FileRelPath in Files:
				os.remove(FilePath)

def LoadTemplateFiles():
	for root, dirs, files in os.walk(TemplateDirectory):
		#for d in dirs:
		#	print(f"DEBUG: {root} {d}")
		dirs[:] = [d for d in dirs if d not in ['.git']]
		for file in files:
			TemplateFileAbsPath = os.path.join(root, file)
			TemplateFileRelPath = os.path.relpath(TemplateFileAbsPath, TemplateDirectory)
			
			# Skip cfgmgr special files
			CacheFileRelPath,TemplateFileExtension = os.path.splitext(TemplateFileRelPath)
			if TemplateFileExtension == '.cfgmgr': continue
			
			# Determine how to handle this file based on mode and extension
			IsTemplate = None
			if TemplateMode == TemplateMode.ExtensionOnly:
				if TemplateFileExtension in ['.tmpl', '.template']:
					IsTemplate = 1
					# CacheFileRelPath already set, removing extionsion
				else:
					CacheFileRelPath = TemplateFileRelPath
					IsTemplate = 0
			elif TemplateMode == TemplateMode.AllExceptExtension:
				if TemplateFileExtension in ['.notmpl', '.notemplate']:
					#CacheFileRelPath already set
					IsTemplate = 0
				else:
					IsTemplate = 1
					CacheFileRelPath = TemplateFileRelPath
			else:
				raise NotImplementedError()
			
			## Save basic data to Files
			Files[CacheFileRelPath] = {
				'TemplatePath': TemplateFileAbsPath,
				'RelPath': CacheFileRelPath,
				'TemplateFileRelPath': TemplateFileRelPath,
				'IsTemplate': IsTemplate}
			
			## add timestamp
			Files[CacheFileRelPath]['TemplateLastModTime'] = os.path.getmtime(TemplateFileAbsPath)
			
			## Add working tree path
			WorkingPath = os.path.join(WorkingDirectory, CacheFileRelPath)
			Files[CacheFileRelPath]['WorkingPath'] = WorkingPath
			if os.path.exists(WorkingPath):
				Files[CacheFileRelPath]['WorkingLastModTime'] = os.path.getmtime(WorkingPath)
			
			## Add cache path
			Files[CacheFileRelPath]['CachePath'] = os.path.join(CacheDirectory, CacheFileRelPath)
	
	
	#print(f"DEBUG: Files={Files}")
	if os.path.exists(ApplyLog):
		with open(ApplyLog, 'r') as file:
			for line in file:
				# Skip comments
				if line.startswith('#'): continue
				
				# Process line
				RelPath,LastApplyHash = line.strip().split(' ', 1)
				
				# Skip non-existant files
				if RelPath not in Files: continue
				
				# Update file properties
				Files[RelPath]['LastApplyHash'] = LastApplyHash



## Define global variables
current_verbosity = 2
#TemplateMode = TemplateMode.ExtensionOnly
TemplateMode = TemplateMode.AllExceptExtension
CacheRoot = '/home/abanker/.cache/cfgmgr'
CacheDirectory = ''
TemplateDirectory = '/home/abanker/tmp/cfgmgr'
TemplateDirectory = '/home/abanker/tmp/cfgmgr.templates'
TemplateDirectory = '/home/abanker/vc/anbanker/config-home'
WorkingDirectory = '/home/abanker'
#https://jinja.palletsprojects.com/en/stable/templates/#whitespace-control
TemplateTool = Environment(
		loader=FileSystemLoader(TemplateDirectory),
		trim_blocks=True)
ApplyLog = ''
Files = {}
TemplateData = {}



def LoadTemplateData():
	# Automatic template data
	TemplateData['hostname'] = socket.gethostname()
	TemplateData['IsWSL'] = os.path.exists('/proc/sys/fs/binfmt_misc/WSLInterop')
	
	# User provided template data
	TemplateDataFile = os.path.join(TemplateDirectory, 'private-data.cfgmgr')
	if os.path.exists(TemplateDataFile):
		# Read file
		with open(TemplateDataFile, 'r') as file:
			# Process each line
			for line in file:
				# Skip comments
				if line.startswith('#'): continue
				
				# Split line into key and value
				key, value = re.split('\s*=\s*', line.strip(), 1)
				
				# Add to TemplateData
				TemplateData[key] = value

def UpdateCacheFiles():
	LoadTemplateData()
	LOG(3, 'cfgmgr: UpdateCacheFiles: Beginning cache update...')
	for RelPath,attr in Files.items():
		LOG(4, f"cfgmgr: UpdateCacheFiles: Processing File: {RelPath}")
		
		## Determine if we need to update the cache file
		if 'TemplateLastModTime' not in attr:
			LOG(3, f"cfgmgr: UpdateCacheFiles: CacheStatus: Deleted: {RelPath}")
			UpdateCache = 0
			del attr['CacheLastModTime']
			os.remove(attr['CachePath'])
		elif 'CacheLastModTime' not in attr:
			LOG(3, f"cfgmgr: UpdateCacheFiles: CacheStatus: Update(missing): {RelPath}")
			UpdateCache = 1
		elif attr['TemplateLastModTime'] > attr['CacheLastModTime']:
			LOG(3, f"cfgmgr: UpdateCacheFiles: CacheStatus: Update(old): {RelPath}")
			UpdateCache = 1
		elif attr['CacheLastModTime'] >= attr['TemplateLastModTime']:
			LOG(3, f"cfgmgr: UpdateCacheFiles: CacheStatus: Unmodified: {RelPath}")
			UpdateCache = 0
		else:
			# Should never happen
			print(f"DEBUG: {RelPath=}, {attr=}")
			raise NotImplementedError()
		
		## If we need to update the cache file
		if UpdateCache:
			#print(f"    attr={attr}")
			CacheFileDir = os.path.dirname(attr['CachePath'])
			
			if not attr['IsTemplate']:
				LOG(3, f"cfgmgr: UpdateCacheFiles: UpdateCache: Copy: {RelPath}")
				os.makedirs(CacheFileDir, exist_ok=True)
				shutil.copy(attr['TemplatePath'], attr['CachePath'])
				os.utime(attr['CachePath'], (attr['TemplateLastModTime'], attr['TemplateLastModTime']))
				
				## Update last mod time
				attr['CacheLastModTime'] = os.path.getmtime(attr['CachePath'])
			else:
				LOG(4, f"cfgmgr: UpdateCacheFiles: UpdateCache: ApplyTemplate: File: {RelPath}")
				
				## Load and apply template
				#template = TemplateTool.get_template(attr['TemplatePath'])
				template = TemplateTool.get_template(attr['TemplateFileRelPath'])
				
				Rendered = template.render(TemplateData)
				attr['CacheContent'] = Rendered
				
				## Skip if empty after rendering
				if Rendered.strip():
					# File is non-empty
					LOG(3, f"cfgmgr: UpdateCacheFiles: UpdateCache: ApplyTemplate: Cache upated: {RelPath}")
					os.makedirs(CacheFileDir, exist_ok=True)
					with open(attr['CachePath'], 'w') as file:
						file.write(Rendered)
					
					## Update last mod time
					attr['CacheLastModTime'] = os.path.getmtime(attr['CachePath'])
				else:
					LOG(3, f"cfgmgr: UpdateCacheFiles: UpdateCache: ApplyTemplate: Empty: {RelPath}")
					# File is empty
					if 'CacheLastModTime' in attr:
						LOG(3, f"cfgmgr: UpdateCacheFiles: UpdateCache: ApplyTemplate: Empty: Removed: {os.remove(attr['CachePath'])}")
						os.remove(attr['CachePath'])
						del attr['CacheLastModTime']
					else:
						LOG(3, f"cfgmgr: UpdateCacheFiles: UpdateCache: ApplyTemplate: Empty: CacheDoesNotExist: {RelPath}")

def CalculateStatus():
	for RelPath, attr in Files.items():
		## Skip if file shouldn't be managed in working directory
		if 'CacheLastModTime' not in attr:
			if 'WorkingLastModTime' not in attr:
				attr['Status'] = 'Empty'
			else:
				attr['Status'] = 'Extra'
		else:
			if 'WorkingLastModTime' not in attr:
				attr['Status'] = 'Missing'
			else:
				if attr['WorkingLastModTime'] == attr['CacheLastModTime']:
					attr['Status'] = 'Same(ts)'
				else:
					if not 'CacheContent' in attr:
						with open(attr['CachePath'], 'r') as file:
							attr['CacheContent'] = file.read()
					
					with open(attr['WorkingPath'], 'r') as file:
						WorkingContent = file.read()
					
					if WorkingContent == attr['CacheContent']:
						attr['Status'] = 'Same(content)'
					elif WorkingContent[0:-1] == attr['CacheContent']:
						attr['Status'] = 'Similar'
					else:
						attr['Status'] = 'Diff'
						with open('/tmp/cfgmgr.w.txt', 'w') as file:
							file.write(WorkingContent)
						with open('/tmp/cfgmgr.c.txt', 'w') as file:
							file.write(attr['CacheContent'])
						if RelPath == ".zshenv": raise NotImplementedError()

def DisplayStatus():
	print('## git status')
	subprocess.run(['git', '-C', TemplateDirectory, 'status'], text=True)
	NeedTitle=1
	for RelPath, attr in Files.items():
		# Skip files with "same" status
		if attr['Status'] == 'Same(ts)': continue
		if attr['Status'] == 'Same(content)': continue
		if attr['Status'] == 'Empty': continue
		if attr['Status'] == 'Similar': continue
		if NeedTitle:
			print("## Differences between template repo and working directory:")
			print("   Run 'cfgmgr apply' to apply template to working directory")
			NeedTitle=0
		print(f"    {attr['Status'].ljust(13)}: {RelPath}")

def LoadWorkingHashes(FilesToHash):
	if not FilesToHash:
		FilesToHash = list(Files.keys())
	
	for FileToHash in FilesToHash:
		if FileToHash not in Files:
			raise UserError(f"ERROR: {FileToHash} is not managed")
		
		attr = Files[FileToHash]
		if os.path.exists(attr['WorkingPath']):
			with open(attr['WorkingPath'], 'r') as file:
				WorkingContent = file.read()
			attr['WorkingHash'] = hashlib.sha256(WorkingContent.encode()).hexdigest()

def Apply(FilesToApply):
	# If no files specified, apply all
	Mode = 'a'
	if not FilesToApply:
		FilesToApply = list(Files.keys())
		Mode = 'w'
	
	with open(ApplyLog, Mode) as LogFile:
		LogFile.write(f"## {datetime.datetime.now()}\n")
		for RelPath in FilesToApply:
			if RelPath not in Files:
				raise UserError(f"ERROR: {RelPath} is not managed")
			
			attr = Files[RelPath]
			
			## Make sure file was not modified in working directory since last apply
			if ('LastApplyHash' in attr) and ('WorkingHash' in attr) and (attr['LastApplyHash'] != attr['WorkingHash']):
				print(f"{RelPath}: File has been modified in working directory - skipping!")
				continue
			
			if attr['Status'] == "Same(content)":
				#print(f"Updating timestamp...")
				os.utime(attr['WorkingPath'], (attr['CacheLastModTime'], attr['CacheLastModTime']))
			elif attr['Status'] == 'Empty':
				#Nothing to do (cache and working don't exist)
				pass
			elif 'CacheLastModTime' not in attr:
				print(f"DEBUG: attr={attr}")
				os.remove(attr['WorkingPath'])
				LogFile.write(f"{RelPath} 00")
			else:
				with open(attr['CachePath'], 'r') as file:
					CacheContent = file.read()
				with open(attr['WorkingPath'], 'w') as file:
					file.write(CacheContent)
				os.utime(attr['WorkingPath'], (attr['CacheLastModTime'], attr['CacheLastModTime']))
				attr['WorkingHash'] = hashlib.sha256(CacheContent.encode()).hexdigest()
				LogFile.write(f"{RelPath} {attr['WorkingHash']}\n")


def GetGitStatusOneline():
	output = subprocess.run(['git', '-C', TemplateDirectory, 'status', '--porcelain=v2', '--branch'], capture_output=True)
	if output.returncode != 0:
		return 'git-error'
	
	OutputLines = output.stdout.decode().split('\n')
	
	# Process git OutputLines to get summary
	Ahead = 0
	Behind = 0
	StatusCount = {}
	for line in OutputLines:
		if not line: continue
		match = re.match(r'^# branch.ab \+(?P<Ahead>\d+) \-(?P<Behind>\d+)', line)
		if match:
			Ahead = int(match.group('Ahead'))
			Behind = int(match.group('Behind'))
			continue
		if re.match(r'^#', line):
			continue
			# Do nothing
		
		match = re.match(r'^1 (?P<XY>..) (?P<SubmoduleState>....) (?P<modeHead>[0-7]{6}) (?P<modeIndex>[0-7]{6}) (?P<modeWorktree>[0-7]{6}) (?P<hashHead>[0-9a-f]{40}) (?P<hashIndex>[0-9a-f]{40}) (?P<path>.+)$', line)
		if match:
			# X is index; Y is working-tree
			if   match.group('XY') == 'A.': StatusCount['A'] = StatusCount.get('A', 0) + 1
			elif match.group('XY') == '.M': StatusCount['m'] = StatusCount.get('m', 0) + 1
			elif match.group('XY') == '.D': StatusCount['d'] = StatusCount.get('d', 0) + 1
			elif match.group('XY') == 'M.': StatusCount['M'] = StatusCount.get('M', 0) + 1
			else:                           StatusCount['?'] = StatusCount.get('?', 0) + 1
			continue
			
		if   re.match(r'^\? (?P<path>.*)$', line): StatusCount['u'] = StatusCount.get('u', 0) + 1
		elif re.match(r'^! (?P<path>.*)$', line) : StatusCount['i'] = StatusCount.get('i', 0) + 1
		else                                     : 
			StatusCount['?'] = StatusCount.get('?', 0) + 1
			print(f"DEBUG: Unmatched line: {line}")
	
	OutputString = ''
	for key, value in StatusCount.items():
		OutputString += f"{key}{value}"
	
	#This looked correct on WSL, but not native
	#if($Ahead       ) { $str .= "⭡$Ahead"; }
	#if($Behind      ) { $str .= "⭣$Behind"; }
	#This looks correct on native
	if Ahead : OutputString += f"⇡{Ahead}"
	if Behind: OutputString += f"⇣{Behind}"
	
	return OutputString



def PrintStatusOneline():
	## Get git status
	GitString = GetGitStatusOneline()
	
	## Get working status
	Extra=0
	Missing=0
	Diff=0
	for RelPath, attr in Files.items():
		# Skip files with "same" status
		if attr['Status'] == 'Exists-extra':
			Extra=Extra+1
		elif attr['Status'] == 'Missing':
			Missing=Missing+1
		elif attr['Status'] == 'Diff':
			Diff=Diff+1
	WorkingString = ''
	if Extra: WorkingString += f"E{Extra}"
	if Missing: WorkingString += f"M{Missing}"
	if Diff: WorkingString += f"D{Diff}"
	
	Separator = ''
	if WorkingString and GitString:
		WorkingString = f"W:{WorkingString}"
		GitString = f"G:{GitString}"
		Separator = ' '
	print(f"{WorkingString}{Separator}{GitString}")


def Add(FilesToAdd):
	for RelPath in FilesToAdd:
		WorkingPath = ''
		TemplatePath = ''
		CachePath = ''
		WorkingLastModTime = 0
		if RelPath in Files:
			## Error if file is a template
			if Files[RelPath]['IsTemplate']:
				raise UserError(f"{RelPath}: Cannot add template file from working directory; update template in repo instead.")
			WorkingPath = Files[RelPath]['WorkingPath']
			TemplatePath = Files[RelPath]['TemplatePath']
			CachePath = Files[RelPath]['CachePath']
			WorkingLastModTime = Files[RelPath]['WorkingLastModTime']
		
		## Copy file from working directory to template directory, and set template time to working time
		if not WorkingPath: WorkingPath = os.path.join(WorkingDirectory, RelPath)
		if not TemplatePath: TemplatePath = os.path.join(TemplateDirectory, RelPath)
		if not CachePath: CachePath = os.path.join(CacheDirectory, RelPath)
		if not WorkingLastModTime: WorkingLastModTime = os.path.getmtime(WorkingPath)
		
		TemplateDir = os.path.dirname(TemplatePath)
		os.makedirs(TemplateDir, exist_ok=True)
		shutil.copy(WorkingPath, TemplatePath)
		os.utime(TemplatePath, (WorkingLastModTime, WorkingLastModTime))
		os.remove(CachePath)
		subprocess.run(['git', '-C', TemplateDirectory, 'add', RelPath], text=True)

def Diff(FilesToDiff):
	FileType1 = 'Template'
	FileType2 = 'Working'
	if FilesToDiff[0] == '--cvw':
		FileType1 = 'Cache'
		FilesToDiff.pop(0)
	elif FilesToDiff[0] == '--tvc':
		FileType2 = 'Cache'
		FilesToDiff.pop(0)
	
	if len(FilesToDiff) == 0:
		raise UserWarning("diff requires arguments")
	
	for RelPath in FilesToDiff:
		if RelPath not in Files:
			raise UserError(f"ERROR: {RelPath} is not managed")
		
		attr = Files[RelPath]
		subprocess.run(['/usr/bin/bcompare', attr[f'{FileType1}Path'], attr[f'{FileType2}Path']], text=True)


if __name__ == "__main__":
	#TODO: Process options
	
	CacheSubdir = TemplateDirectory.lstrip('/').replace('/','--')
	if not CacheSubdir: CacheSubdir = 'ROOT_DIR'
	CacheDirectory = os.path.join(CacheRoot, CacheSubdir)
	ApplyLog = os.path.join(TemplateDirectory, 'apply-log.cfgmgr')
	LoadTemplateFiles()
	LoadCacheData()
	
	## Remove program name
	sys.argv.pop(0)
	
	# Get sub-command
	if len(sys.argv) < 1:
		SubCommand = 'status'
	else:
		SubCommand = sys.argv.pop(0)
	
	if SubCommand == 'UpdateCache':
		UpdateCacheFiles()
	
	elif SubCommand == 'status':
		UpdateCacheFiles()
		CalculateStatus()
		DisplayStatus()
	
	elif SubCommand == 'statusOneline':
		UpdateCacheFiles()
		CalculateStatus()
		PrintStatusOneline()
	
	elif SubCommand == 'git':
		subprocess.run(['git', '-C', TemplateDirectory, '--no-pager', *sys.argv], text=True)
	
	elif SubCommand == 'diff':
		UpdateCacheFiles()
		Diff(sys.argv)
	
	elif SubCommand == 'add':
		UpdateCacheFiles()
		CalculateStatus()
		Add(sys.argv)
	
	elif SubCommand == 'apply':
		UpdateCacheFiles()
		CalculateStatus()
		LoadWorkingHashes([])
		Apply(sys.argv)
	else:
		#raise Exception('Usage Error', f"ERROR: Unknown sub-command: {SubCommand}")
		print(f"ERROR: Unknown sub-command: {SubCommand}")
		exit(1)
